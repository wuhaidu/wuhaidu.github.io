<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Netty实战笔记]]></title>
    <url>%2F2019%2F06%2F25%2F1%2F</url>
    <content type="text"><![CDATA[Netty 实战笔记1.通道建立连接时,ChannelHandler的channelActive()被回调 —-入站2.Future提供了一种在操作完成时通知应用程序的方式。入站事件包括：1）连接已被激活或者连接失活2）数据读取3）用户事件4）错误事件 出站事件动作：打开或者关闭远程节点的连接将数据写到或者冲刷到套接字 每个Channel都拥有一个与之相关联的ChannelPipeline,其持有一个ChannelHandler的实例链。默认情况下，ChannelHandler会把对它的方法的调用的调用转发给链中的下一个ChannelHandler。因为，如果exceptionCaught()方法没有被该链中的某处实现，那么所接收的异常将会被传递到ChannelPipeline的尾端并被记录。 SimpleChannelInboundHandler与ChannelInboundHandler客户端使用SimpleChannelInboundHandler服务端使用ChannelInboundHandler 在客户端，当channelRead0()方法完成时，你已经有了传入消息，并且已经处理完它了，当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的byteBuf的内存引用。在服务端，你仍然需要将传入的消息返回给发送者，而write()操作是异步的，直到channelRead()方法返回后仍然可能没有完成。这个时间点不会被释放当writeAndFlush()方法被调用时被释放 释放byyeBuf内存方法： ReferenceCountUtil.release(msg);或者直接writeAndFlush() ##Netty的组件及设计 Channel——SocketEventLoop——控制流、多线程处理、并发ChannelFuture——异步通知 ###Channel接口基本的I/o操作,bind()、connect()、read()和write()12345EmbeddedChannelLocalServerChannelNioDatagramChannelNioSctpChannelNioSocketChannel ###EventLoop接口处理连接的生命周期中所发生的事件。12345一个EventLoopGroup包含一个或者多个EventLoop;一个EventLoop在它的生命周期内只和一个Thread绑定所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理一个Channel在它的生命周期内只注册与一个EventLoop一个EventLoop可能会被分配给一个或者多个Channel ###ChannelFuture接口Netty 中所有的 I/O 操作都是异步的。因为一个操作可能不会立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。为此，Netty 提供了ChannelFuture 接口，其 addListener()方法注册了一个 ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知。 ###ChannelPipeline和ChannelHandler关系ChannelPipeline提供了ChannelHandler链的容器,并定义了用于在该链上传播入站和出站事件流的API，当Channel被创建时，它会被自动地分配到它专属的ChannelPipelineChannelHandler安装到ChannelPipeline过程：12341.一个ChannelInitializer的实现被注册到ServerBootstrap中2.当ChannelInitializer.initChannel()方法被调用时,ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler;3.ChannelInitializer将它自己从ChannelPipeline中移除 当ChannelHandler 被添加到ChannelPipeline 时，它将会被分配一个ChannelHandler￾Context，其代表了 ChannelHandler 和 ChannelPipeline 之间的绑定，它将会被分配一个ChannelHandler可以得到该ChannelHandler的下一个或者上一个Handler 在 Netty 中，有两种发送消息的方式。你可以直接写到 Channel 中，也可以 写到和 Channel￾Handler相关联的ChannelHandlerContext对象中。前一种方式将会导致消息从Channel￾Pipeline 的尾端开始流动，而后者将导致消息从 ChannelPipeline 中的下一个 Channel￾Handler 开始流动。 ServerBootstrap 将绑定到一个端口，因为服务器必须要监听连接，而 Bootstrap 则是由想要连接到远程节点的客户端应用程序所使用的引导一个客户端只需要一个 EventLoopGroup，但是一个ServerBootstrap 则需要两个（也可以是同一个实例）。 为什么？服务器需要两组不同的Channel。第一组只包含一个ServerChannel,代表服务器自身的已绑定到某个本地端口的正在监听的套接字。第二组，包含所有已创建的用来处理传入客户端连接的Channel ##传输1234OIO——阻塞传输NIO——异步传输Local——JVM内部的异步通信Embedded——测试你的ChannelHandler ###传输API ####ChannelChannel接口用于所有I/O操作,每个Channel都会被分配一个ChannelPopeline和ChannelConfig,ChannelConfig包含了该Channel的所有配置，并支持热更新。Channel是有序的，实现了Comparable的子接口，如果两个不同的Channel实例返回了想通的散列码，那么AbstractChannel中的compareTO()方法的实现将会抛出一个Error。ChannelPipeline 持有所有将应用于入站和出站数据以及事件的 ChannelHandler 实例。ChannelPipeline实现了一种拦截过滤器模式，一个命令的输出端连接到下一个命令的输入端。 ChannelHandler的典型用途包括:12345将数据从一种格式转换为另一种格式；1. 提供异常的通知；2.提供 Channel 变为活动的或者非活动的通知；3.提供当 Channel 注册到 EventLoop 或者从 EventLoop 注销时的通知；4.提供有关用户自定义事件的通知。 ##ByteBuf12341.ByteBuf——Netty的数据容器2.API的详细信息3.用例4.内存分配 优点:1234567891011121314151617它可以被用户自定义的缓冲区类型扩展通过内置的复合缓冲区类型实现了透明的零拷贝容量可以按需增长(类似于StringBuilder)在读写这两种模式之间切换不需要调用ByteBuffer的flip()方法读写使用了不同的索引支持方法的链式调用支持引用技术支持池化Netty池化：池化技术概叙，基于JVM堆内存之上，构建更高一层的内存池，通过调用内存池allocate方法获取内存空间，调用release方法将内存区域归还内存池，内存池面临的首要问题是碎片回收，内存池在频繁申请和释放空间后，还能尽可能连续的内存空间用于大块内存空间的分配有两种算法优化这一块的内存分配：伙伴系统和slab系统伙伴系统：完全二叉树的结构组织，分配内存时不断二分大块内存，释放内存时将空闲的伙伴合成大块内存slab系统：主要解决内部碎片问题，将预先申请的一块内存区域包装成一个内存集，该内存集将申请到的大块内存分割成相等大小的内存片。 ###堆缓冲区最常用的ByteBuf模式是将数据存储在JVM的堆空间中。这种模式被称为支撑数据，它能在没有使用池化的情况下提供快速的分配和释放。适用于有遗留的数据需要处理的情况 ###直接缓冲区直接缓冲区是另一种ByteBuf模式。JDK1.4中引入的ByteBuffer类允许JVM实现通过本地调用来分配内存。 ###复合缓冲区为多个ByteBuf提供一个聚合视图。可以根据需要添加或者删除ByteBuf实例。Netty的CompositeByteBuf实现了这个模式，提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示1234注意:CompositeByteBuf 中的 ByteBuf 实例可能同时包含直接内存分配和非直接内存分配。如果其中只有一个实例，那么对 CompositeByteBuf 上的 hasArray()方法的调用将返回该组件上的 hasArray()方法的值；否则它将返回 false 12345678扩展：零拷贝详解，零拷贝可以避免无谓的copy动作软件和硬件进行信息传输可以通过DMA来完成，DMA操作不消耗CPU传统的读写操作都需要进行两次copy操作读:应用——&gt;内核——&gt;硬盘——&gt;(DMA)内核缓冲区——&gt;(CPU copy)应用缓冲区写:应用——&gt;内核——&gt;(CPU copy)内存缓冲区——&gt;(DMA copy)protocl engine——&gt;clinet读写操作需要进行两次CPU copy。内核缓冲区通常叫做kernel socket（读时：read） buffer。 ###字节级操作 ####随机访问索引ByteBuf的索引是从零开始的：第一个字节的索引是0，最后一个字节的索引总是capacity()-1。通过get/set开头的方法不会增加readIndex/writerIndex。 ####顺序访问索引ByteBuf同时具有读索引和写索引，但是JDK的ByteBuffer却只有一个索引，这就是为什么必须嗲用flip()方法来在读模式和写模式之间进行切换的原因。 ByteBuf被两个索引划分成3个区域：可丢弃的字节+可读字节+可写字节，如图： 当调用discardReadBytes()方法回收可丢弃字节的空间后，readerIndex会重置为0，writerIndex会减少,可读空间会进行缓存复制操作，将可读空间移到初始位置 ###ByteBuf分配按需分配，ByteBufAllocator接口 ####@Sharable的用法多个ChannelPipeline共享一个ChannelHandler,常用于收集跨越多个Channel的统计信息 ###异常处理 ####处理入站异常如果在处理入站时间的过程中有异常被抛出，那么它将从它在ChannelInboundHandler里被触发的那一点开始流经ChannelPipeline.需要在ChannelInboundHandler实现中重写下面方法。12public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception 例如:12345678public class InboundExceptionHandler extends ChannelInboundHandlerAdapter &#123; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 异常会继续按照入站方向流动(就像所有的入站事件一样)，所以可以实现一个上面逻辑的ChannelnboundHandler放在最后。 ####处理出站异常1234561.每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的ChannelFutureListener将在操作完成时被通知该操作是否成功还是出错。2.几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。但是，ChannelPromise 还具有提供立即通知的可写方法：ChannelPromise setSuccess();ChannelPromise setFailure(Throwable cause); ###EventLoop和线程模型 ####EventLoop接口一个EventLoop将由一个永远不会改变的Thread驱动，任务可直接提交给EventLoop实现，以立即执行或者调度执行，根据配置和可用核心的不同,单个EventLoop可能会被指派用于服务多个Channel ###使用Netty的ChannelOption和属性可以使用 option()方法来将 ChannelOption 应用到引导。你所提供的值将会被自动应用到引导所创建的所有 Channel。 ###decode()decode(ChannelHandlerContext ctx, ByteBuf in, List out)这是你必须实现的唯一抽象方法。decode()方法被调用时将会传入一个包含了传入数据的 ByteBuf，以及一个用来添加解码消息的 List。对这个方法的调用将会重复进行，直到确定没有新的元素被添加到该 List，或者该 ByteBuf 中没有更多可读取的字节时为止。然后，如果该 List 不为空，那么它的内容将会被传递给ChannelPipeline 中的下一个 ChannelInboundHandler ##解码器 12将字节解码为消息——ByteToMessageDecoder和ReplayingDecoder将一种消息类型解码为另一种——MessageToMessageDecoder ReplayingDecoder扩展了ByteToMessageDecoder类，使我们不必调用readableBytes()方法。 ##编码器12将消息编码为字节将消息编码为消息 encode(ChannelHandlerContext ctx, I msg, ByteBuf out)encode()方法是你需要实现的唯一抽象方法。它被调用时将会传入要被该类编码为 ByteBuf 的（类型为 I 的）出站消息。该 ByteBuf 随后将会被转发给 ChannelPipeline中的下一个 ChannelOutboundHandler]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java高并发程序设计之并发基础]]></title>
    <url>%2F2019%2F04%2F17%2F1%2F</url>
    <content type="text"><![CDATA[一.线程生命周期]]></content>
  </entry>
  <entry>
    <title><![CDATA[实战Java高并发程序设计(一)]]></title>
    <url>%2F2019%2F04%2F17%2F1%2F</url>
    <content type="text"><![CDATA[一.并发设计的一些概念1.同步与异步 同步:同步方法调用一旦开始，调用者必须等到方法调用返回后才能继续后续的行为。 异步:方法调用就会立即返回，调用者不需要等待就可以继续后续的操作。 2.并发与并行 严格意义上来说，并行的多个任务是真实的同时执行，而并发偏重于多个任务交替执行，这个过程只是交替的，一会运行任务A，一会运行任务B,系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉 实际上，如果系统只有一个CPU,任务不可能实现真实的并行,毕竟一个CPU一次只能执行一条指令。真实的并行也只能出现在拥有多个CPU的系统中(比如多核CPU) 3.临界区 临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，其他线程要使用这个资源就必须等待。 4.阻塞与非阻塞 等待资源的线程需要等待，等待会导致线程挂起。这种情况下就是阻塞。 5.死锁(Deadlock)、饥饿(Starvation)、活锁(Livelock) 死锁:多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。 饥饿:如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。 活锁:多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。 二.并发级别1.阻塞2.无饥饿 主要体现在非公平锁与公平锁情况下，对于非公平锁而言，系统运行高优先级的线程插队，就有可能导致低优先级线程产生饥饿。而如果锁是公平的，满足先来后到，那么饥饿就不会产生。 例如:ReentrantLock构造函数中提供了两种锁：创建公平锁和非公平锁（默认）。 3.无障碍 线程不会因为临界区的问题导致被挂起。无障碍的多线程并不一定能顺畅的运行，因为当临界区中存在严重的冲突时，所有的线程可能都会不断回滚自己的操作，而没有一个线程能走出临界区，这种情况下会影响系统的正常执行。 4.无锁 无锁的并发都是无障碍的，但是不同的是。无锁的并发保证必然有一个线程额能够在有限步内完成操作离开临界区。 5.无等待 无锁只要求一个线程可以在有限步内完成操作，而五等待则在无锁的基础上更进异步扩展。它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题。如果限制这个步骤上限，还可以进一步分解为有界无等待和线程数无关的无等待几种。 一种典型的无等待结构就是RCU(Read-Copy-Update)。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的,他们既不会被锁定等待也不会引起冲突。例如:ConcurrentHashMap 三.回到Java:JMM1.原子性 一个操作不可被中断.例如:赋值操作， int i=1;但是不使用int型而使用long型的话，在32位系统中，long型数据的读写不是原子性的(long有64位)。 2.可见性 可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。在串行程序中，可见性问题并不存在。在并行程序中，如果一个线程改变了某个全局变量的值，那么其他线程未必就会这个改动。例如多个CPU时，CPU1与CPU2会由于编译器优化或者硬件优化的缘故，产生可见性问题。 其他可导致可见性:指定重排、编辑器的优化 3.有序性 在并发时，程序的执行可能就会出现乱序。因为程序在执行时。可能会进行指令重排序，重排序后的指令与原指令未必一致。指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。 一条指令的执行分为以下几步: 取指 IF 译码和区寄存器操作数 ID 执行或者有效地址计算 EX 存储器访问 MEM 写回 WB CPU为什么会去指令重排序？原因是CPU使用流水线技术来执行指令，需要消除指令之间的停顿。 汇编指令的执行不是一步就可以执行完毕的，在CPU的实际工作时，需要分多个步骤依次执行，每个步骤所涉及到的硬件也可能不同。 例如下面两条指令的执行12指令1 IF ID EX MEM WB指令2 IF ID EX MEM WB 假如每条指令的每个步骤是1s,如果指令2等指令1执行完毕之后才开始执行，就等待5s,但是如果使用流水线后，指令2只需等待1毫秒就可以执行，性能得到了很大的提升。 如果存在多条指令指令,例如:123456a = b + c;LW R1,b IF ID EX MEM WBLW R2,c IF ID EX MEM WBADD R3,R1,R2 IF ID 等待 MEM WBSW a,R3 IF 等待 EX MEM WB 上述指令的执行会在ADD的时候进行等待停顿，原因R2的数据还没准备完成,还未WB到寄存器R2中。导致下面的步骤会继续等待。 再看下面例子，会出现大量的指令等待:1234567891011a = b + c;d = e - f;LW R1,b IF ID EX MEM WBLW R2,c IF ID EX MEM WBADD R3,R1,R2 IF ID 等待 MEM WBSW a,R3 IF 等待 EX MEM WBLW R4,e IF ID EX MEM WBLR R5,f IF ID EX MEM WBSUB R6,R4,R5 IF ID 等待 MEM WB SW d,R6 IF ID 等待 MEM WB 如果把指令(ADD R3,R1,R2),(SW a,R3 )与(LW R4,e),(LR R5,f)交换位置后，就可以把停顿的时间利用起来:1234567891011a = b + c;d = e - f;LW R1,b IF ID EX MEM WBLW R2,c IF ID EX MEM WBLW R4,e IF ID EX MEM WBLR R5,f IF ID EX MEM WBADD R3,R1,R2 IF ID EX MEM WBSW a,R3 IF ID EX MEM WBSUB R6,R4,R5 IF ID EX MEM WB SW d,R6 IF ID EX MEM WB 所以使用指令重排虽然带来的乱序，但是相对于提高的CPU的性能，这点牺牲是值得的。 代码案例: 1234567891011121314151617181920212223242526272829303132333435public class OrderingTest &#123; public static void main(String[] args) &#123; OrderExample orderExample = new OrderExample(); Thread t1 = new Thread(() -&gt;&#123; orderExample.writer(); &#125;); Thread t2 = new Thread(() -&gt; &#123; orderExample.reader(); &#125;); t1.start(); t2.start(); &#125;&#125;class OrderExample&#123; int a = 0; boolean flag = false; public void writer()&#123; a = 1; flag = true; System.out.println(Thread.currentThread().getName() + &quot;:a = &quot; + a); &#125; public void reader()&#123; if(flag) &#123; int i = a + 1; System.out.println(Thread.currentThread().getName() + &quot;:i = &quot; + i); &#125; &#125;&#125; 运行结果有: 12Thread-0:a = 1Thread-1:i = 1 4.哪些指令不能重排:Happen-Before规则 程序顺序原则:一个线程内保证语义的串行性 volatile原则:volatile变量的写，先发生于读，这保证了volatile变量的可见性 锁规则:解锁(unlock)必然发生在随后的加锁(lock)前 传递性:A先于B,B先于C,那么A必然先于C 线程的start()方法优先于它的每一个动作 线程的所有操作先于线程的终结(Thread.jion()) 线程的中断(interrupt())先于被中断线程的代码 对象的构造函数执行、结束先于finalize()方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[page]]></title>
    <url>%2F2019%2F04%2F16%2F1%2F</url>
    <content type="text"><![CDATA[AV.initialize("", ""); //需要写上leancloud的key var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) { for (var i=0;i]]></content>
  </entry>
</search>
