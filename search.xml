<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实战Java高并发程序设计(一)]]></title>
    <url>%2F2019%2F04%2F17%2F1%2F</url>
    <content type="text"><![CDATA[一.并发设计的一些概念1.同步与异步 同步:同步方法调用一旦开始，调用者必须等到方法调用返回后才能继续后续的行为。 异步:方法调用就会立即返回，调用者不需要等待就可以继续后续的操作。 2.并发与并行 严格意义上来说，并行的多个任务是真实的同时执行，而并发偏重于多个任务交替执行，这个过程只是交替的，一会运行任务A，一会运行任务B,系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉 实际上，如果系统只有一个CPU,任务不可能实现真实的并行,毕竟一个CPU一次只能执行一条指令。真实的并行也只能出现在拥有多个CPU的系统中(比如多核CPU) 3.临界区 临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，其他线程要使用这个资源就必须等待。 4.阻塞与非阻塞 等待资源的线程需要等待，等待会导致线程挂起。这种情况下就是阻塞。 5.死锁(Deadlock)、饥饿(Starvation)、活锁(Livelock) 死锁:多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。 饥饿:如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。 活锁:多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。 二.并发级别1.阻塞2.无饥饿 主要体现在非公平锁与公平锁情况下，对于非公平锁而言，系统运行高优先级的线程插队，就有可能导致低优先级线程产生饥饿。而如果锁是公平的，满足先来后到，那么饥饿就不会产生。 例如:ReentrantLock构造函数中提供了两种锁：创建公平锁和非公平锁（默认）。 3.无障碍 线程不会因为临界区的问题导致被挂起。无障碍的多线程并不一定能顺畅的运行，因为当临界区中存在严重的冲突时，所有的线程可能都会不断回滚自己的操作，而没有一个线程能走出临界区，这种情况下会影响系统的正常执行。 4.无锁 无锁的并发都是无障碍的，但是不同的是。无锁的并发保证必然有一个线程额能够在有限步内完成操作离开临界区。 5.无等待 无锁只要求一个线程可以在有限步内完成操作，而五等待则在无锁的基础上更进异步扩展。它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题。如果限制这个步骤上限，还可以进一步分解为有界无等待和线程数无关的无等待几种。 一种典型的无等待结构就是RCU(Read-Copy-Update)。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的,他们既不会被锁定等待也不会引起冲突。例如:ConcurrentHashMap 三.回到Java:JMM1.原子性 一个操作不可被中断.例如:赋值操作， int i=1;但是不使用int型而使用long型的话，在32位系统中，long型数据的读写不是原子性的(long有64位)。 2.可见性 可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。在串行程序中，可见性问题并不存在。在并行程序中，如果一个线程改变了某个全局变量的值，那么其他线程未必就会这个改动。例如多个CPU时，CPU1与CPU2会由于编译器优化或者硬件优化的缘故，产生可见性问题。 其他可导致可见性:指定重排、编辑器的优化 3.有序性 在并发时，程序的执行可能就会出现乱序。因为程序在执行时。可能会进行指令重排序，重排序后的指令与原指令未必一致。指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。 一条指令的执行分为以下几步: 取指 IF 译码和区寄存器操作数 ID 执行或者有效地址计算 EX 存储器访问 MEM 写回 WB CPU为什么会去指令重排序？原因是CPU使用流水线技术来执行指令，需要消除指令之间的停顿。 汇编指令的执行不是一步就可以执行完毕的，在CPU的实际工作时，需要分多个步骤依次执行，每个步骤所涉及到的硬件也可能不同。 例如下面两条指令的执行12指令1 IF ID EX MEM WB指令2 IF ID EX MEM WB 假如每条指令的每个步骤是1s,如果指令2等指令1执行完毕之后才开始执行，就等待5s,但是如果使用流水线后，指令2只需等待1毫秒就可以执行，性能得到了很大的提升。 如果存在多条指令指令,例如:123456a = b + c;LW R1,b IF ID EX MEM WBLW R2,c IF ID EX MEM WBADD R3,R1,R2 IF ID 等待 MEM WBSW a,R3 IF 等待 EX MEM WB 上述指令的执行会在ADD的时候进行等待停顿，原因R2的数据还没准备完成,还未WB到寄存器R2中。导致下面的步骤会继续等待。 再看下面例子，会出现大量的指令等待:1234567891011a = b + c;d = e - f;LW R1,b IF ID EX MEM WBLW R2,c IF ID EX MEM WBADD R3,R1,R2 IF ID 等待 MEM WBSW a,R3 IF 等待 EX MEM WBLW R4,e IF ID EX MEM WBLR R5,f IF ID EX MEM WBSUB R6,R4,R5 IF ID 等待 MEM WB SW d,R6 IF ID 等待 MEM WB 如果把指令(ADD R3,R1,R2),(SW a,R3 )与(LW R4,e),(LR R5,f)交换位置后，就可以把停顿的时间利用起来:1234567891011a = b + c;d = e - f;LW R1,b IF ID EX MEM WBLW R2,c IF ID EX MEM WBLW R4,e IF ID EX MEM WBLR R5,f IF ID EX MEM WBADD R3,R1,R2 IF ID EX MEM WBSW a,R3 IF ID EX MEM WBSUB R6,R4,R5 IF ID EX MEM WB SW d,R6 IF ID EX MEM WB 所以使用指令重排虽然带来的乱序，但是相对于提高的CPU的性能，这点牺牲是值得的。 代码案例: 1234567891011121314151617181920212223242526272829303132333435public class OrderingTest &#123; public static void main(String[] args) &#123; OrderExample orderExample = new OrderExample(); Thread t1 = new Thread(() -&gt;&#123; orderExample.writer(); &#125;); Thread t2 = new Thread(() -&gt; &#123; orderExample.reader(); &#125;); t1.start(); t2.start(); &#125;&#125;class OrderExample&#123; int a = 0; boolean flag = false; public void writer()&#123; a = 1; flag = true; System.out.println(Thread.currentThread().getName() + &quot;:a = &quot; + a); &#125; public void reader()&#123; if(flag) &#123; int i = a + 1; System.out.println(Thread.currentThread().getName() + &quot;:i = &quot; + i); &#125; &#125;&#125; 运行结果有: 12Thread-0:a = 1Thread-1:i = 1 4.哪些指令不能重排:Happen-Before规则 程序顺序原则:一个线程内保证语义的串行性 volatile原则:volatile变量的写，先发生于读，这保证了volatile变量的可见性 锁规则:解锁(unlock)必然发生在随后的加锁(lock)前 传递性:A先于B,B先于C,那么A必然先于C 线程的start()方法优先于它的每一个动作 线程的所有操作先于线程的终结(Thread.jion()) 线程的中断(interrupt())先于被中断线程的代码 对象的构造函数执行、结束先于finalize()方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[page]]></title>
    <url>%2F2019%2F04%2F16%2F1%2F</url>
    <content type="text"><![CDATA[AV.initialize("", ""); //需要写上leancloud的key var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) { for (var i=0;i]]></content>
  </entry>
</search>
